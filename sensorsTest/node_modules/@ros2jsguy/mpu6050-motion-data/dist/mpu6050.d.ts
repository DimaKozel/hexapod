/// <reference types="node" />
import { Euler, Quaternion, Vector3 } from 'three-math-ts';
import { I2CHelper } from './i2c-helper';
export { Euler, Quaternion, Vector3 } from 'three-math-ts';
export declare type I2cOptions = {
    i2cAddress?: number;
    baudRate?: number;
};
export interface Data3D {
    x: number;
    y: number;
    z: number;
}
export interface MotionData {
    accel: Data3D;
    gyro: Data3D;
}
export interface RPY {
    roll: number;
    pitch: number;
    yaw: number;
}
export declare enum Register {
    RA_XA_OFFS_H = 6,
    RA_XA_OFFS_L_TC = 7,
    RA_YA_OFFS_H = 8,
    RA_YA_OFFS_L_TC = 9,
    RA_ZA_OFFS_H = 10,
    RA_XG_OFFS_USRH = 19,
    RA_XG_OFFS_USRL = 20,
    RA_YG_OFFS_USRH = 21,
    RA_YG_OFFS_USRL = 22,
    RA_ZG_OFFS_USRH = 23,
    RA_ZG_OFFS_USRL = 24,
    RA_SMPLRT_DIV = 25,
    RA_CONFIG = 26,
    RA_GYRO_CONFIG = 27,
    RA_ACCEL_CONFIG = 28,
    RA_FIFO_EN = 35,
    RA_INT_PIN_CFG = 55,
    RA_INT_ENABLE = 56,
    RA_INT_STATUS = 58,
    RA_ACCEL_XOUT_H = 59,
    RA_ACCEL_XOUT_L = 60,
    RA_ACCEL_YOUT_H = 61,
    RA_ACCEL_YOUT_L = 62,
    RA_ACCEL_ZOUT_H = 63,
    RA_ACCEL_ZOUT_L = 64,
    RA_TEMP_OUT_H = 65,
    RA_TEMP_OUT_L = 66,
    RA_GYRO_XOUT_H = 67,
    RA_GYRO_XOUT_L = 68,
    RA_GYRO_YOUT_H = 69,
    RA_GYRO_YOUT_L = 70,
    RA_GYRO_ZOUT_H = 71,
    RA_GYRO_ZOUT_L = 72,
    RA_USER_CTRL = 106,
    RA_PWR_MGMT_1 = 107,
    RA_BANK_SEL = 109,
    RA_MEM_START_ADDR = 110,
    RA_MEM_R_W = 111,
    RA_FIFO_COUNTH = 114,
    RA_FIFO_R_W = 116,
    RA_WHO_AM_I = 117
}
export declare enum ClockSource {
    INTERNAL = 0,
    PLL_XGYRO = 1,
    PLL_YGYRO = 2,
    PLL_ZGYRO = 3,
    PLL_EXT32K = 4,
    PLL_EXT19M = 5,
    KEEP_RESET = 7
}
export declare enum ClockDiv {
    DIV_348 = 0,
    DIV_333 = 1,
    DIV_320 = 2,
    DIV_308 = 3,
    DIV_296 = 4,
    DIV_286 = 5,
    DIV_276 = 6,
    DIV_267 = 7,
    DIV_258 = 8,
    DIV_500 = 9,
    DIV_471 = 10,
    DIV_444 = 11,
    DIV_421 = 12,
    DIV_400 = 13,
    DIV_381 = 14,
    DIV_364 = 15
}
export declare enum AccelFsRange {
    FS_2 = 0,
    FS_4 = 1,
    FS_8 = 2,
    FS_16 = 3
}
export declare enum GyroFsRange {
    FS_250 = 0,
    FS_500 = 1,
    FS_1000 = 2,
    FS_2000 = 3
}
export declare enum FsyncIntLevel {
    ACTIVE_HIGH = 0,
    ACTIVE_LOW = 1
}
/**
 * A MPU6050 driver class based on the [I2Cdevlib library](https://www.i2cdevlib.com/devices/mpu6050),
 * providing fused orientation (quaternion), acceleration and rotational data
 * via the on-device digital motion processor (DMP). Includes sensor offset
 * calibration and raw unfused sensor data. This module is implemented in
 * TypeScript and runs on Raspberry Pi 3 & 4.
 */
export declare class MPU6050 {
    private i2cAddress;
    private i2cBaudRate;
    private i2cHelper;
    private dmpPacketSize;
    static getI2CHelper(baud: number): I2CHelper;
    constructor(i2cOptions?: I2cOptions);
    /**
     * Power on and prepare for general usage.
     * This will activate the device and take it out of sleep mode (which must be done
     * after start-up). This function also sets both the accelerometer and the gyroscope
     * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
     * the clock source to use the X Gyro for reference, which is slightly better than
     * the default internal clock source.
     */
    initialize(): void;
    /**
     * Terminate communications with the MPU6050 chip.
     * Includes disabling DMP, FSync interrupt and DataReady interrupt.
     */
    shutdown(): void;
    /**
     * Get the MPU6050 I2C slave address.
     * @returns The I2C slave address.
     */
    getDeviceI2CAddr(): number;
    /**
     * Get Device ID.
     * This register is used to verify the identity of the device (0b110100, 0x34).
     * @see Register.RA_WHO_AM_I
     * @see Register.WHO_AM_I_BIT
     * @see Register.WHO_AM_I_LENGTH
     * @returns Devices ID (6 bits only! should be 0x34)
     */
    getDeviceID(): number;
    /**
     * Verify the I2C connection.
     * Make sure the device is connected and responds as expected.
     * @returns True if connection is valid, false otherwise
     */
    testConnection(): boolean;
    /**
     * Trigger a full device reset.
     * A small delay of ~50ms may be desirable after triggering a reset.
     * @see MPU6050.RA_PWR_MGMT_1
     * @see MPU6050.PWR1_DEVICE_RESET_BIT
     */
    reset(): void;
    /**
     * Get sleep mode status.
     * Setting the SLEEP bit in the register puts the device into very low power
     * sleep mode. In this mode, only the serial interface and internal registers
     * remain active, allowing for a very low standby current. Clearing this bit
     * puts the device back into normal mode. To save power, the individual standby
     * selections for each of the gyros should be used if any gyro axis is not used
     * by the application.
     * @returns Current sleep mode enabled status
     * @see MPU6050.RA_PWR_MGMT_1
     * @see MPU6050.PWR1_SLEEP_BIT
     */
    getSleepEnabled(): boolean;
    /**
     * Set sleep mode status.
    * @param enabled New sleep mode enabled status
    * @see getSleepEnabled()
    * @see MPU6050.RA_PWR_MGMT_1
    * @see MPU6050.PWR1_SLEEP_BIT
    */
    setSleepEnabled(enabled: boolean): void;
    /**
     * Get clock source setting.
     * @returns Current clock source setting
     * @see MPU6050.RA_PWR_MGMT_1
     * @see MPU6050.PWR1_CLKSEL_BIT
     * @see MPU6050.PWR1_CLKSEL_LENGTH
     */
    getClockSource(): ClockSource;
    /**
     * Set clock source setting.
     * An internal 8MHz oscillator, gyroscope based clock, or external sources can
     * be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator
     * or an external source is chosen as the clock source, the MPU-60X0 can operate
     * in low power modes with the gyroscopes disabled.
     *
     * Upon power up, the MPU-60X0 clock source defaults to the internal oscillator.
     * However, it is highly recommended that the device be configured to use one of
     * the gyroscopes (or an external clock source) as the clock reference for
     * improved stability. The clock source can be selected according to the following table:
     *
     * <pre>
     * CLK_SEL | Clock Source
     * --------+--------------------------------------
     * 0       | Internal oscillator
     * 1       | PLL with X Gyro reference
     * 2       | PLL with Y Gyro reference
     * 3       | PLL with Z Gyro reference
     * 4       | PLL with external 32.768kHz reference
     * 5       | PLL with external 19.2MHz reference
     * 6       | Reserved
     * 7       | Stops the clock and keeps the timing generator in reset
     * </pre>
     *
     * @param source New clock source setting
     * @see getClockSource()
     * @see MPU6050.RA_PWR_MGMT_1
     * @see MPU6050.PWR1_CLKSEL_BIT
     * @see MPU6050.PWR1_CLKSEL_LENGTH
     */
    setClockSource(source: ClockSource): void;
    /** Get gyroscope output rate divider.
     * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero
     * Motion detection, and Free Fall detection are all based on the Sample Rate.
     * The Sample Rate is generated by dividing the gyroscope output rate by
     * SMPLRT_DIV:
     *
     * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
     *
     * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
     * 7), and 1kHz when the DLPF is enabled (see Register 26).
     *
     * Note: The accelerometer output rate is 1kHz. This means that for a Sample
     * Rate greater than 1kHz, the same accelerometer sample may be output to the
     * FIFO, DMP, and sensor registers more than once.
     *
     * For a diagram of the gyroscope and accelerometer signal paths, see Section 8
     * of the MPU-6000/MPU-6050 Product Specification document.
     *
     * @returns Current sample rate
     * @see MPU6050.RA_SMPLRT_DIV
     */
    getRate(): number;
    /**
     * Set gyroscope sample rate divider.
     * @param rate New sample rate divider
     * @see getRate()
     * @see MPU6050.RA_SMPLRT_DIV
     */
    setRate(rate: number): void;
    /**
     * Get full-scale gyroscope range.
     * The FS_SEL parameter allows setting the full-scale range of the gyro sensors,
     * as described in the table below.
     *
     * <pre>
     * 0 = +/- 250 degrees/sec
     * 1 = +/- 500 degrees/sec
     * 2 = +/- 1000 degrees/sec
     * 3 = +/- 2000 degrees/sec
     * </pre>
     *
     * @returns Current full-scale gyroscope range setting
     * @see MPU6050.GYRO_FS_250
     * @see MPU6050.RA_GYRO_CONFIG
     * @see MPU6050.GCONFIG_FS_SEL_BIT
     * @see MPU6050.GCONFIG_FS_SEL_LENGTH
     */
    getFullScaleGyroRange(): GyroFsRange;
    /**
     * Set full-scale gyroscope range.
     * @param range New full-scale gyroscope range value
     * @see getFullScaleRange()
     * @see MPU6050.GYRO_FS_250
     * @see MPU6050.RA_GYRO_CONFIG
     * @see MPU6050.GCONFIG_FS_SEL_BIT
     * @see MPU6050.GCONFIG_FS_SEL_LENGTH
     */
    setFullScaleGyroRange(range: GyroFsRange): void;
    /**
     * Get full-scale accelerometer range.
     * The FS_SEL parameter allows setting the full-scale range of the accelerometer
     * sensors, as described in the table below.
     *
     * <pre>
     * 0 = +/- 2g
     * 1 = +/- 4g
     * 2 = +/- 8g
     * 3 = +/- 16g
     * </pre>
     *
     * @returns Current full-scale accelerometer range setting
     * @see MPU6050.ACCEL_FS_2
     * @see MPU6050.RA_ACCEL_CONFIG
     * @see MPU6050.ACONFIG_AFS_SEL_BIT
     * @see MPU6050.ACONFIG_AFS_SEL_LENGTH
     */
    getFullScaleAccelRange(): AccelFsRange;
    /**
     * Set full-scale accelerometer range.
     * @param range New full-scale accelerometer range setting
     * @see getFullScaleAccelRange()
     */
    setFullScaleAccelRange(range: AccelFsRange): void;
    /**
     * Get accelerometer FIFO enabled value.
     * When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H,
     * ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be
     * written into the FIFO buffer.
     * @returns Current accelerometer FIFO enabled value
     * @see MPU6050.RA_FIFO_EN
     */
    getAccelFIFOEnabled(): boolean;
    /**
     * Set accelerometer FIFO enabled value.
     * @param enabled New accelerometer FIFO enabled value
     * @see getAccelFIFOEnabled()
     * @see MPU6050.RA_FIFO_EN
     */
    setAccelFIFOEnabled(enabled: boolean): void;
    /**
     * Get gyroscope X-axis FIFO enabled value.
     * When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and
     * 68) to be written into the FIFO buffer.
     * @returns Current gyroscope X-axis FIFO enabled value
     * @see MPU6050_RA_FIFO_EN
     */
    getXGyroFIFOEnabled(): boolean;
    /**
     * Set gyroscope X-axis FIFO enabled value.
     * @param enabled New gyroscope X-axis FIFO enabled value
     * @see getXGyroFIFOEnabled()
     * @see MPU6050_RA_FIFO_EN
     */
    setXGyroFIFOEnabled(enabled: boolean): void;
    /**
     * Get gyroscope Y-axis FIFO enabled value.
     * When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and
     * 70) to be written into the FIFO buffer.
     * @returns Current gyroscope Y-axis FIFO enabled value
     * @see MPU6050_RA_FIFO_EN
     */
    getYGyroFIFOEnabled(): boolean;
    /**
     * Set gyroscope Y-axis FIFO enabled value.
     * @param enabled New gyroscope Y-axis FIFO enabled value
     * @see getYGyroFIFOEnabled()
     * @see MPU6050_RA_FIFO_EN
     */
    setYGyroFIFOEnabled(enabled: boolean): void;
    /**
     * Get gyroscope Z-axis FIFO enabled value.
     * When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and
     * 72) to be written into the FIFO buffer.
     * @returns Current gyroscope Z-axis FIFO enabled value
     * @see MPU6050_RA_FIFO_EN
     */
    getZGyroFIFOEnabled(): boolean;
    /**
     * Set gyroscope Z-axis FIFO enabled value.
     * @param enabled New gyroscope Z-axis FIFO enabled value
     * @see getZGyroFIFOEnabled()
     * @see MPU6050_RA_FIFO_EN
     */
    setZGyroFIFOEnabled(enabled: boolean): void;
    /**
     * Get interrupt logic level mode.
     * Will be set 0 for active-high, 1 for active-low.
     * @returns Current interrupt mode (0=active-high, 1=active-low)
     * @see MPU6050.RA_INT_PIN_CFG
     * @see MPU6050.INTCFG_INT_LEVEL_BIT
     */
    getInterruptMode(): number;
    /**
     * Set interrupt logic level mode.
     * @param mode New interrupt mode (0=active-high, 1=active-low)
     * @see getInterruptMode()
     * @see MPU6050.RA_INT_PIN_CFG
     * @see MPU6050.INTCFG_INT_LEVEL_BIT
     */
    setInterruptMode(mode: boolean): void;
    /**
     * Get the latch mode of the interrupt pin.
     * @returns true if interrupt pin remains active until cleared; otherwise interrupt pin emits 50 us pulse
     */
    getInterruptLatchEnabled(): boolean;
    /**
     * Enable or disable latch mode on the interrupt pin
     * @param enabled - when true if interrupt pin remains active until cleared; otherwise interrupt pin emits 50 us pulse
     */
    setInterruptLatchEnabled(enabled: boolean): void;
    /**
     * Get the interrupt pin clearing mode.
     * @returns 1 if interrupt pin is cleared on any data read; 0 if interrput pin is clearer only by reading the interrupt status register
     */
    getInterruptClearMode(): 0 | 1;
    /**
     * Specify if interrupt pin is cleared
     * @param mode - 1 clears interrupt pin on any data read; 0 clears interrupt pin only by reading the interrupt status register
     */
    setInterruptClearMode(mode: 0 | 1): void;
    /**
     * Get interrupt register byte.
     * Full register byte for all interrupts, for quick reading. Each bit will be
     * set 0 for disabled, 1 for enabled.
     * @returns Current interrupt register byte
     * @see MPU6050.RA_INT_ENABLE
     * @see MPU6050.INTERRUPT_FF_BIT
     */
    getInterruptRegister(): number;
    /**
     * Set full interrupt enabled status.
     * Full register byte for all interrupts, for quick reading. Each bit should be
     * set 0 for disabled, 1 for enabled.
     * @param byte - New interrupts byte
     * @see getIntFreefallEnabled()
     * @see MPU6050.RA_INT_ENABLE
     * @see MPU6050.INTERRUPT_FF_BIT
     */
    setInterruptRegister(byte: number): void;
    /**
     * Get FSYNC pin interrupt enabled setting.
     * Will be set 0 for disabled, 1 for enabled.
     * @returns Current interrupt enabled setting
     * @see RegisterRA_INT_PIN_CFG
     * @see INTCFG_FSYNC_INT_EN_BIT
     */
    getFSyncInterruptEnabled(): boolean;
    /**
     * Set FSYNC pin interrupt enabled setting.
     * @param enabled New FSYNC pin interrupt enabled setting
     * @see getFSyncInterruptEnabled()
     * @see MPU6050_RA_INT_PIN_CFG
     * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT
     */
    setFSyncInterruptEnabled(enabled: boolean): void;
    /**
     * Get Data Ready interrupt enabled setting.
     * This event occurs each time a write operation to all of the sensor registers
     * has been completed. Will be set 0 for disabled, 1 for enabled.
     * @returns Current interrupt enabled status
     * @see MPU6050.RA_INT_ENABLE
     * @see MPU6050.INTERRUPT_DATA_RDY_BIT
     */
    getInterruptDataReadyEnabled(): boolean;
    /**
     * Set Data Ready interrupt enabled status.
    * @param enabled New interrupt enabled status
    * @see getIntDataReadyEnabled()
    * @see MPU6050.RA_INT_CFG
    * @see MPU6050.INTERRUPT_DATA_RDY_BIT
    */
    setInterruptDataReadyEnabled(enabled: boolean): void;
    /**
     * Get Data Ready interrupt enabled setting.
     * This event occurs each time a write operation to all of the sensor registers
     * has been completed. Will be set 0 for disabled, 1 for enabled.
     * @returns Current interrupt enabled status
     * @see MPU6050.RA_INT_ENABLE
     * @see MPU6050.INTERRUPT_DATA_RDY_BIT
     */
    getInterruptDMPEnabled(): boolean;
    /**
     * Set DMP interrupt enabled status.
    * @param enabled New interrupt enabled status
    * @see getIntDataReadyEnabled()
    * @see MPU6050.RA_INT_CFG
    * @see MPU6050.INTERRUPT_DATA_RDY_BIT
    */
    setInterruptDMPEnabled(enabled: boolean): void;
    /**
     * Get FIFO Buffer Overflow interrupt enabled status.
     * Will be set 0 for disabled, 1 for enabled.
     * @returns Current interrupt enabled status
     * @see MPU6050.RA_INT_ENABLE
     * @see MPU6050.INTERRUPT_FIFO_OFLOW_BIT
     */
    getInterruptFIFOBufferOverflowEnabled(): boolean;
    /**
     * Set FIFO Buffer Overflow interrupt enabled status.
     * @param enabled New interrupt enabled status
     * @see getIntFIFOBufferOverflowEnabled()
     * @see MPU6050.RA_INT_ENABLE
     * @see MPU6050.INTERRUPT_FIFO_OFLOW_BIT
     */
    setInterruptFIFOBufferOverflowEnabled(enabled: boolean): void;
    /**
     * Get full set of interrupt status bits.
     * These bits clear to 0 after the register has been read. Very useful
     * for getting multiple INT statuses, since each single bit read clears
     * all of them because it has to read the whole byte.
     * @returns Current interrupt status
     * @see MPU6050.RA_INT_STATUS
     */
    getInterruptStatus(): number;
    /**
     * Get Data Ready interrupt status.
     * This bit automatically sets to 1 when a Data Ready interrupt has been
     * generated. The bit clears to 0 after the register has been read.
     * @returns Current interrupt status
     * @see MPU6050.RA_INT_STATUS
     * @see MPU6050.INTERRUPT_DATA_RDY_BIT
     */
    getInterruptDataReadyStatus(): boolean;
    /**
     * Get FIFO enabled status.
     * When this bit is set to 0, the FIFO buffer is disabled. The FIFO buffer
     * cannot be written to or read from while disabled. The FIFO buffer's state
     * does not change unless the MPU-60X0 is power cycled.
     * @returns Current FIFO enabled status
     * @see MPU6050.RA_USER_CTRL
     * @see MPU6050.USERCTRL_FIFO_EN_BIT
     */
    getFIFOEnabled(): boolean;
    /**
     * Set FIFO enabled status.
     * @param enabled New FIFO enabled status
     * @see getFIFOEnabled()
     * @see MPU6050.RA_USER_CTRL
     * @see MPU6050.USERCTRL_FIFO_EN_BIT
     */
    setFIFOEnabled(enabled: boolean): void;
    /**
     * Reset the FIFO.
     * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
     * bit automatically clears to 0 after the reset has been triggered.
     * @see MPU6050.RA_USER_CTRL
     * @see MPU6050.USERCTRL_FIFO_RESET_BIT
     */
    resetFIFO(): void;
    /**
     * Get current FIFO buffer size.
     * This value indicates the number of bytes stored in the FIFO buffer. This
     * number is in turn the number of bytes that can be read from the FIFO buffer
     * and it is directly proportional to the number of samples available given the
     * set of sensor data bound to be stored in the FIFO (register 35 and 36).
     * @returns Current FIFO buffer size
     */
    getFIFOCount(): number;
    /**
     * Returns bytes read from the FIFO buffer in a volitale buffer.
     *
     * Bytes read from the FIFO buffer are returned in a volitale buffer, i.e.,
     * the buffer is overwritten upon each FIFO read. Therefore you should copy
     * any bytes for which you need to reference beyond the current FIFO read.
     *
     * Data is written to the FIFO in order of register number (from lowest to highest).
     * If all the FIFO enable flags (see below) are enabled and all External Sensor
     * Data registers (Registers 73 to 96) are associated with a Slave device, the
     * contents of registers 59 through 96 will be written in order at the Sample
     * Rate.
     *
     * The contents of the sensor data registers (Registers 59 to 96) are written
     * into the FIFO buffer when their corresponding FIFO enable flags are set to 1
     * in FIFO_EN (Register 35). An additional flag for the sensor data registers
     * associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).
     *
     * If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is
     * automatically set to 1. This bit is located in INT_STATUS (Register 58).
     * When the FIFO buffer has overflowed, the oldest data will be lost and new
     * data will be written to the FIFO.
     *
     * If the FIFO buffer is empty, reading this register will return the last byte
     * that was previously read from the FIFO until new data is available. The user
     * should check FIFO_COUNT to ensure that the FIFO buffer is not read when
     * empty.
     *
     * @returns volitale bytes from the FIFO buffer
     */
    getFIFOBytes(length: number): Buffer;
    /**
     * Read the 1st byte from the FIFO buffer.
     * @returns A byte
     */
    getFIFOByte(): number;
    /**
     *
     * @returns The dlpf configuration setting
     */
    getDLPF(): number;
    setDLPF(filterConfig: number): void;
    /**
     * Get raw 6-axis motion sensor readings (accel/gyro).
     * Retrieves all currently available motion sensor values.
     * @see getAccel()
     * @see getGyro()
     * @see MPU6050.RA_ACCEL_XOUT_H
     */
    getMotionData(): MotionData;
    /**
     * Get raw 3-axis accelerometer readings.
     * @returns current accelerometer data
     * @see MPU6050.RA_ACCEL_XOUT_H
     */
    getAccel(): Data3D;
    /**
     * Get raw 3-axis gyroscope readings.
     * @returns current gyroscop data
     * @see MPU6050.RA_GYRO_XOUT_H
     */
    getGyro(): Data3D;
    /**
     * Get the device temperature in Celcius.
     * @returns Temperature in Celcius
     */
    getTemperature(): number;
    setSensorOffsets(xAccelOffset: number, yAccelOffset: number, zAccelOffset: number, xGyroOffset: number, yGyroOffset: number, zGyroOffset: number): void;
    /**
     * Access the X-axis acceleration offset.
     * @returns X-axis offset
     */
    getXAccelOffset(): number;
    /**
     * Update the X-axis acceleration offset.
     * @param offset
     */
    setXAccelOffset(offset: number): void;
    /**
     * Access the Y-axis acceleration offset.
     * @returns y-axis offset
     */
    getYAccelOffset(): number;
    /**
     * Update the Y-axis acceleration offset.
     * @param offset
     */
    setYAccelOffset(offset: number): void;
    /**
     * Access the Z-axis acceleration offset.
     * @returns z-axis offset
     */
    getZAccelOffset(): number;
    /**
     * Update the Z-axis acceleration offset.
     * @param offset
     */
    setZAccelOffset(offset: number): void;
    /**
     * Access the X-axis gyro offset.
     * @returns X-axis offset
     */
    getXGyroOffset(): number;
    /**
     * Update the Z-axis gyro offset.
     * @param offset
     */
    setXGyroOffset(offset: number): void;
    /**
     * Access the Y-axis gyr offset.
     * @returns y-axis offset
     */
    getYGyroOffset(): number;
    /**
     * Update the Y-axis gyro.
     * @param offset
     */
    setYGyroOffset(offset: number): void;
    /**
     * Access the Z-axis gyro offset.
     * @returns z-axis offset
     */
    getZGyroOffset(): number;
    /**
     * Update the Z-axis gyro.
     * @param offset
     */
    setZGyroOffset(offset: number): void;
    /**
     * Access the DMP enable/disable status.
     * @returns true when enabled; false otherwise.
     */
    getDMPEnabled(): boolean;
    /**
     * Enable or disabled the DMP.
     * @param enabled
     */
    setDMPEnabled(enabled: boolean): void;
    /**
     * Asynchronously reset DMP module. This bit auto clears after one clock cycle.
     */
    resetDMP(): void;
    /**
     * Initialize digital motion processing (DMP).
     *
     * Upon completion the MPU6050 state is:
     *   Full reset, All interrupts cleared.
     *   Clock source = X-Gyro
     *   Accelerometer Fullscale Range = 2g
     *   Gyrometer Fullscale Range = +-2000 deg/sec
     *   DMP Raw Data Interrupt enabled
     *   Rate divider = 4
     *   Load DMP program image
     *   FIFO enabled & reset
     *   Set clear interrupt on any read
     *   DMP is disabled; To enable DMP call setDMPEnabled(true)
     *
     * For detailed descriptins of all registers and there purpose google "MPU-6000/MPU-6050 Register Map and Descriptions"
     */
    dmpInitialize(): void;
    protected setMemoryBank(bank: number, prefetchEnabled?: boolean, userBank?: boolean): void;
    protected setMemoryStartAddress(address: number): void;
    protected writeProgMemoryBlock(data: Uint8Array, bank?: number, address?: number, verify?: boolean): void;
    protected writeMemoryBlock(data: Uint8Array, bank?: number, address?: number, verify?: boolean, useProgMem?: boolean): void;
    /**
     * Determine if a DMP packet of data is available in the FIFO buffer.
     * @returns True when a package is ready to be read; false otherwise.
     */
    dmpPacketAvailable(): boolean;
    /**
     * Get the size of a DMP FIFO packet
     * @returns The packet size in bytes.
     */
    dmpGetFIFOPacketSize(): number;
    /** Get latest byte from FIFO buffer no matter how much time has passed.
    * ===                  GetCurrentFIFOPacket                    ===
    * ================================================================
    * Returns 1) when nothing special was done
    *         2) when recovering from overflow
    *         0) when no valid data is available
    * ================================================================ */
    dmpGetCurrentFIFOPacket(): Buffer | undefined;
    /**
     * Get the 3-axis accelerometer reading from the DMP packet.
     * @param packet - DMP packet of bytes
     * @returns The accelerometer reading
     */
    dmpGetAccel(packet: Buffer): Data3D;
    /**
     * Get the 3-axis gyroscope reading from the DMP packet.
     * @param packet - DMP packet of bytes
     * @returns The gyroscope reading
     */
    dmpGetGyro(packet: Buffer): Data3D;
    /**
     * Get 6-axis motion sensor readings (accel/gyro).
     * Retrieves all currently available motion sensor values.
     * @param packet - DMP packet to process.
     * @returns MotionData from the DMP packet
     * @see dmpGetAccel()
     * @see dmpGetGyro()
     */
    dmpGetMotionData(packet: Buffer): MotionData;
    /**
     * Get the DMP computed quaternion
     * @param packet - DMP packet
     * @returns The quaternion.
     */
    dmpGetQuaternion(packet: Buffer): Quaternion;
    /**
     * Get the gravity vector in
     * @param packet
     * @returns
     */
    dmpGetGravity(packet: Buffer): Vector3;
    /**
     * Compute the Euler angle from a DMP quaternion.
     * @param q - quaternion
     * @returns The Euler angle.
     */
    dmpGetEuler(q: Quaternion): Euler;
    /**
     * Compute the yaw, roll and pitch from the DMP quaternion and gravity vector.
     * @param q - The quaternion
     * @param gravity - The gravity vector
     * @returns The roll, yaw and pitch
     */
    dmpGetYawPitchRoll(q: Quaternion, gravity: Vector3): RPY;
    /**
     * Compute the 3-axis linear acceleration vector from the dmp acceleration and gravity vector.
     * @param accel - 3-axis acceleration
     * @param gravity - gravity vector
     * @returns The linear acceleration vector
     */
    dmpGetLinearAccel(accel: Data3D, gravity: Vector3): Vector3;
    /**
    * Calibrate the gyroscope, (i.e., compute X, Y and Z offsets),
    * in 6-7 iterations (600-700 readings). The X, Y and Z offsets are printed to stdout
    * for future use with the setXGyroOffset(), setYGyroOffset() and setZGyroOffset()
    * respectively.
    *
    * @param [enableOutput=true] - enables output of info msgs
    * @param [loops=6] - number of calibration iterations to run
    */
    calibrateGyro(enableOutput?: boolean, loops?: number): void;
    /**
     * Calibrate the accelerometer, (i.e., compute X, Y and Z offsets),
     * in 6-7 iterations (600-700 readings). The X, Y and Z offsets are printed to stdout
     * for future use with the setXAccelOffset(), setYAccelOffset() and setZAccelOffset()
     * respectively.
     *
     * @param [enableOutput=true] - enables output of info msgs
     * @param [loops=6] - number of calibration iterations to run
     */
    calibrateAccel(enableOutput?: boolean, loops?: number): void;
    protected PID(ReadAddress: number, kP: number, kI: number, Loops: number, enableOutput?: boolean): void;
    /**
     *
     */
    printActiveOffsets(): void;
    /**
     * Read a byte stored in the specified register.
     * @param register - The register to read
     * @returns The byte stored in the register
     */
    getRegister(register: number): number;
}
//# sourceMappingURL=mpu6050.d.ts.map