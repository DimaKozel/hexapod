import type { Euler } from './Euler';
import type { Matrix3 } from './Matrix3';
import type { Quaternion } from './Quaternion';
import { Vector3 } from './Vector3';
declare class Matrix4 {
    readonly isMatrix4 = true;
    elements: number[];
    constructor();
    set(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number): this;
    identity(): this;
    clone(): Matrix4;
    copy(m: Matrix4): this;
    copyPosition(m: Matrix4): this;
    setFromMatrix3(m: Matrix3): this;
    extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): this;
    makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): this;
    extractRotation(m: Matrix4): this;
    makeRotationFromEuler(euler: Euler): this;
    makeRotationFromQuaternion(q: Quaternion): this;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    multiply(m: Matrix4, n?: Matrix4): this;
    premultiply(m: Matrix4): this;
    multiplyMatrices(a: Matrix4, b: Matrix4): this;
    multiplyScalar(s: number): this;
    determinant(): number;
    transpose(): this;
    setPosition(...params: [Vector3] | [number, number, number]): this;
    invert(): this;
    scale(v: Vector3): this;
    getMaxScaleOnAxis(): number;
    makeTranslation(x: number, y: number, z: number): this;
    makeRotationX(theta: number): this;
    makeRotationY(theta: number): this;
    makeRotationZ(theta: number): this;
    makeRotationAxis(axis: Vector3, angle: number): this;
    makeScale(x: number, y: number, z: number): this;
    makeShear(x: number, y: number, z: number): this;
    compose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
    decompose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
    makePerspective(left: number, right: number, top: number, bottom: number, near: number, far: number): this;
    makeOrthographic(left: number, right: number, top: number, bottom: number, near: number, far: number): this;
    equals(matrix: Matrix4): boolean;
    fromArray(array: number[], offset?: number): this;
    toArray(array?: number[], offset?: number): number[];
}
export { Matrix4 };
