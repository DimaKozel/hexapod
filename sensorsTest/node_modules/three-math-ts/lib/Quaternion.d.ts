import type { Euler } from './Euler';
import type { Matrix4 } from './Matrix4';
import type { Vector3 } from './Vector3';
declare class Quaternion {
    static slerp(qa: Quaternion, qb: Quaternion, qm: Quaternion, t: number): void;
    static slerpFlat(dst: number[], dstOffset: number, src0: number[], srcOffset0: number, src1: number[], srcOffset1: number, t: number): void;
    static multiplyQuaternionsFlat(dst: number[], dstOffset: number, src0: number[], srcOffset0: number, src1: number[], srcOffset1: number): number[];
    readonly isQuaternion = true;
    _x: number;
    _y: number;
    _z: number;
    _w: number;
    constructor(x?: number, y?: number, z?: number, w?: number);
    get x(): number;
    set x(value: number);
    get y(): number;
    set y(value: number);
    get z(): number;
    set z(value: number);
    get w(): number;
    set w(value: number);
    set(x: number, y: number, z: number, w: number): this;
    clone(): Quaternion;
    copy(quaternion: Quaternion): this;
    setFromEuler(euler: Euler, update?: boolean): this;
    setFromAxisAngle(axis: Vector3, angle: number): this;
    setFromRotationMatrix(m: Matrix4): this;
    setFromUnitVectors(vFrom: Vector3, vTo: Vector3): this;
    angleTo(q: Quaternion): number;
    rotateTowards(q: Quaternion, step: number): this;
    identity(): this;
    invert(): this;
    conjugate(): this;
    dot(v: Quaternion): number;
    lengthSq(): number;
    length(): number;
    normalize(): this;
    multiply(q: Quaternion, p?: Quaternion): this;
    premultiply(q: Quaternion): this;
    multiplyQuaternions(a: Quaternion, b: Quaternion): this;
    slerp(qb: Quaternion, t: number): this;
    slerpQuaternions(qa: Quaternion, qb: Quaternion, t: number): void;
    equals(quaternion: Quaternion): boolean;
    fromArray(array: number[], offset?: number): this;
    toArray(array?: number[], offset?: number): number[];
    _onChange(callback: () => void): this;
    _onChangeCallback(): void;
}
export { Quaternion };
