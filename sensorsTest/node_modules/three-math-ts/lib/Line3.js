"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Line3 = void 0;
const Vector3_1 = require("./Vector3");
const MathUtils_1 = require("./MathUtils");
const _startP = new Vector3_1.Vector3();
const _startEnd = new Vector3_1.Vector3();
class Line3 {
    constructor(start = new Vector3_1.Vector3(), end = new Vector3_1.Vector3()) {
        this.isLine3 = true;
        this.start = start;
        this.end = end;
    }
    set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    }
    copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    }
    getCenter(target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .getCenter() target is now required');
            target = new Vector3_1.Vector3();
        }
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .delta() target is now required');
            target = new Vector3_1.Vector3();
        }
        return target.subVectors(this.end, this.start);
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end);
    }
    distance() {
        return this.start.distanceTo(this.end);
    }
    at(t, target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .at() target is now required');
            target = new Vector3_1.Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t = startEnd_startP / startEnd2;
        if (clampToLine) {
            t = MathUtils_1.MathUtils.clamp(t, 0, 1);
        }
        return t;
    }
    closestPointToPoint(point, clampToLine, target) {
        const t = this.closestPointToPointParameter(point, clampToLine);
        if (target === undefined) {
            console.warn('THREE.Line3: .closestPointToPoint() target is now required');
            target = new Vector3_1.Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    }
    equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
    clone() {
        return new Line3().copy(this);
    }
}
exports.Line3 = Line3;
//# sourceMappingURL=Line3.js.map