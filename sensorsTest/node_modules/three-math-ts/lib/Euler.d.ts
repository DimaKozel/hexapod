import { Quaternion } from './Quaternion';
import { Vector3 } from './Vector3';
import { Matrix4 } from './Matrix4';
export declare type IOrder = 'XYZ' | 'YZX' | 'ZXY' | 'XZY' | 'YXZ' | 'ZYX';
declare class Euler {
    static readonly DefaultOrder: IOrder;
    static readonly RotationOrders: IOrder[];
    readonly isEuler = true;
    _x: number;
    _y: number;
    _z: number;
    _order: IOrder;
    constructor(x?: number, y?: number, z?: number, order?: IOrder);
    get x(): number;
    set x(value: number);
    get y(): number;
    set y(value: number);
    get z(): number;
    set z(value: number);
    get order(): IOrder;
    set order(value: IOrder);
    set(x: number, y: number, z: number, order: IOrder): this;
    clone(): Euler;
    copy(euler: Euler): this;
    setFromRotationMatrix(m: Matrix4, order?: IOrder, update?: boolean): this;
    setFromQuaternion(q: Quaternion, order?: IOrder, update?: boolean): this;
    setFromVector3(v: Vector3, order?: IOrder): this;
    reorder(newOrder: IOrder): this;
    equals(euler: Euler): boolean;
    fromArray(array: [number, number, number, IOrder]): this;
    toArray(array?: Array<number | IOrder>, offset?: number): (number | IOrder)[];
    toVector3(optionalResult?: Vector3): Vector3;
    _onChange(callback: () => void): this;
    _onChangeCallback(): void;
}
export { Euler };
